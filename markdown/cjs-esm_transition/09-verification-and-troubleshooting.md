# 9. 移行後の検証とトラブルシューティング

コードの変換作業が完了したら、アプリケーション全体が意図通りに動作することを保証するための検証作業が不可欠です。また、移行プロセス中には特有のエラーに遭遇することがよくあります。この章では、検証のための戦略と、よくある問題のトラブルシューティング方法を解説します。

## 9.1. 移行後の検証戦略

### 9.1.1. 静的解析の実行

まず、コードレベルでの問題を洗い出すために、設定を更新したツールチェインを再度実行します。

1.  **リンターの実行:**
    `ESLint` を実行し、新たな構文エラーやルール違反がないかを確認します。
    ```bash
    npx eslint . --fix
    ```

2.  **フォーマッターの実行:**
    念のため `Prettier` を実行し、コード全体のフォーマットを統一します。
    ```bash
    npx prettier --write "**/*.js"
    ```

### 9.1.2. 機能テスト (手動)

アプリケーションを実際に動かし、主要な機能が損なわれていないか（リグレッションが発生していないか）を確認します。

-   **`agent` の検証ポイント:**
    -   単体で正常に起動するか (`npm run dev:agent`)。
    -   `manager` からのWebSocket接続を受け付けられるか。
    -   サーバー作成、起動、停止、削除などの基本操作が正常に完了するか。
    -   サーバーログやメトリクスが `manager` に正しく送信されるか。

-   **`manager` の検証ポイント:**
    -   アプリケーションが正常に起動するか (`npm run dev:manager`)。
    -   `agent` への接続とサーバーリストの表示が正常に行われるか。
    -   UI上のボタンクリックやフォーム入力が正しく反応し、意図した動作（`agent`へのコマンド送信など）につながるか。
    -   `agent` からのプッシュ通知（サーバー状態の更新など）を受けてUIがリアルタイムに更新されるか。
    -   ウィンドウのリサイズや終了などのライフサイクルイベントが正常に動作するか。

### 9.1.3. ビルドプロセスの検証

最後に、本番用のビルドが正常に完了することを確認します。
```bash
npm run build
```
`electron-builder` がESM化されたファイルを正しくパッケージングできるかを確認します。ビルドが成功したら、生成された実行可能ファイル（AppImage, debなど）を起動し、同様に基本的な動作確認を行います。

## 9.2. よくある問題とトラブルシューティング

### エラー: `Error [ERR_MODULE_NOT_FOUND]: Cannot find module '...'`

-   **原因:**
    1.  **拡張子の欠落:** 最もよくある原因です。ESMでは、相対パスでのファイルインポート時に拡張子 (`.js`) を省略できません。
    2.  **パスの間違い:** `import` しているモジュールのパスが単純に間違っている。
    3.  **`exports` の設定ミス:** 依存ライブラリ側の `package.json` の `exports` フィールドが正しく設定されておらず、Node.jsがモジュールを解決できない。

-   **解決策:**
    1.  `import` 文のパスに `.js` や `.json` などの拡張子が正しく付与されているか確認します。
    2.  対象ファイルが実際にそのパスに存在するか確認します。
    3.  ライブラリが原因の場合、そのライブラリのバージョンを更新するか、Issueトラッカーを確認します。

### エラー: `Error [ERR_REQUIRE_ESM]: require() of ES Module ... not supported.`

-   **原因:** CommonJSファイル (`.cjs` や `"type": "module"` がない環境の `.js`) から、ESMファイル (`.mjs` や `"type": "module"` がある環境の `.js`) を同期的に `require()` しようとしています。

-   **解決策:**
    CJS側で、`require()` の代わりに非同期の `import()` を使ってESMを読み込みます。
    ```javascript
    async function loadEsModuleFromCjs() {
      const myModule = await import('./my-esm-module.js');
      return myModule;
    }
    ```

### エラー: `ReferenceError: require is not defined` / `__dirname is not defined`

-   **原因:** ESMとして扱われているファイル (`"type": "module"` が有効な `.js` ファイル) の中で、CJSのグローバル変数や関数 (`require`, `module`, `exports`, `__filename`, `__dirname`) を使用しようとしています。

-   **解決策:**
    -   `require` -> `import` に書き換えます。
    -   `module.exports` / `exports` -> `export` / `export default` に書き換えます。
    -   `__dirname` / `__filename` -> `import.meta.url` と `path`, `url` モジュールを使ったパターンに置き換えます。 (詳細はガイド3を参照)

### 問題: 循環参照 (Circular Dependencies)

-   **原因:** CJSとESMでは、循環参照の解決方法が異なります。CJSでは、循環参照が発生すると、未完成の `module.exports` オブジェクト (`{}`) が返されることがあり、これが原因で `TypeError: ... is not a function` のようなエラーを引き起こすことがあります。ESMは循環参照に対してより洗練された仕組みを持っていますが、それでも意図しない `undefined` が発生する可能性があります。

-   **解決策:**
    -   **依存関係の見直し:** 根本的な解決策は、循環参照をなくすようにコードの依存関係をリファクタリングすることです。モジュールAとBが相互に依存している場合、両方が依存する共通の機能Cを別のモジュールに切り出すなどの方法が考えられます。
    -   **動的 `import()` の利用:** どうしても循環参照を避けられない場合、片方の `import` をファイルのトップレベルではなく、関数の中などで動的に `import()` することで、実行タイミングを遅延させ、循環参照の問題を回避できる場合があります。